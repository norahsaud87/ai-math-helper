{"ast":null,"code":"/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim Stöhr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView, Uint8Array */\n\n;\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var hasblobSlice = typeof Blob !== 'undefined' && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n  loadImage.blobSlice = hasblobSlice && function () {\n    var slice = this.slice || this.webkitSlice || this.mozSlice;\n    return slice.apply(this, arguments);\n  };\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [],\n      // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  };\n\n  // Parses image meta data and calls the callback with an object argument\n  // with the following properties:\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n  // The options argument accepts an object and supports the following\n  // properties:\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n  // * disableImageHead: Disables creating the imageHead property.\n  loadImage.parseMetaData = function (file, callback, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {};\n    // eslint-disable-next-line no-param-reassign\n    data = data || {};\n    var that = this;\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\n    var maxMetaDataSize = options.maxMetaDataSize || 262144;\n    var noMetaData = !(typeof DataView !== 'undefined' && file && file.size >= 12 && file.type === 'image/jpeg' && loadImage.blobSlice);\n    if (noMetaData || !loadImage.readFile(loadImage.blobSlice.call(file, 0, maxMetaDataSize), function (e) {\n      if (e.target.error) {\n        // FileReader error\n        // eslint-disable-next-line no-console\n        console.log(e.target.error);\n        callback(data);\n        return;\n      }\n      // Note on endianness:\n      // Since the marker and length bytes in JPEG files are always\n      // stored in big endian order, we can leave the endian parameter\n      // of the DataView methods undefined, defaulting to big endian.\n      var buffer = e.target.result;\n      var dataView = new DataView(buffer);\n      var offset = 2;\n      var maxOffset = dataView.byteLength - 4;\n      var headLength = offset;\n      var markerBytes;\n      var markerLength;\n      var parsers;\n      var i;\n      // Check for the JPEG marker (0xffd8):\n      if (dataView.getUint16(0) === 0xffd8) {\n        while (offset < maxOffset) {\n          markerBytes = dataView.getUint16(offset);\n          // Search for APPn (0xffeN) and COM (0xfffe) markers,\n          // which contain application-specific meta-data like\n          // Exif, ICC and IPTC data and text comments:\n          if (markerBytes >= 0xffe0 && markerBytes <= 0xffef || markerBytes === 0xfffe) {\n            // The marker bytes (2) are always followed by\n            // the length bytes (2), indicating the length of the\n            // marker segment, which includes the length bytes,\n            // but not the marker bytes, so we add 2:\n            markerLength = dataView.getUint16(offset + 2) + 2;\n            if (offset + markerLength > dataView.byteLength) {\n              // eslint-disable-next-line no-console\n              console.log('Invalid meta data: Invalid segment size.');\n              break;\n            }\n            parsers = loadImage.metaDataParsers.jpeg[markerBytes];\n            if (parsers && !options.disableMetaDataParsers) {\n              for (i = 0; i < parsers.length; i += 1) {\n                parsers[i].call(that, dataView, offset, markerLength, data, options);\n              }\n            }\n            offset += markerLength;\n            headLength = offset;\n          } else {\n            // Not an APPn or COM marker, probably safe to\n            // assume that this is the end of the meta data\n            break;\n          }\n        }\n        // Meta length must be longer than JPEG marker (2)\n        // plus APPn marker (2), followed by length bytes (2):\n        if (!options.disableImageHead && headLength > 6) {\n          if (buffer.slice) {\n            data.imageHead = buffer.slice(0, headLength);\n          } else {\n            // Workaround for IE10, which does not yet\n            // support ArrayBuffer.slice:\n            data.imageHead = new Uint8Array(buffer).subarray(0, headLength);\n          }\n        }\n      } else {\n        // eslint-disable-next-line no-console\n        console.log('Invalid JPEG file: Missing JPEG marker.');\n      }\n      callback(data);\n    }, 'readAsArrayBuffer')) {\n      callback(data);\n    }\n  };\n\n  // Replaces the image head of a JPEG blob with the given one.\n  // Calls the callback with the new Blob:\n  loadImage.replaceHead = function (blob, head, callback) {\n    loadImage.parseMetaData(blob, function (data) {\n      callback(new Blob([head, loadImage.blobSlice.call(blob, data.imageHead.byteLength)], {\n        type: 'image/jpeg'\n      }));\n    }, {\n      maxMetaDataSize: 256,\n      disableMetaDataParsers: true\n    });\n  };\n  var originalTransform = loadImage.transform;\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(file, function (data) {\n        originalTransform.call(loadImage, img, options, callback, file, data);\n      }, options, data);\n    } else {\n      originalTransform.apply(loadImage, arguments);\n    }\n  };\n});","map":{"version":3,"names":["factory","define","amd","module","exports","require","window","loadImage","hasblobSlice","Blob","prototype","slice","webkitSlice","mozSlice","blobSlice","apply","arguments","metaDataParsers","jpeg","parseMetaData","file","callback","options","data","that","maxMetaDataSize","noMetaData","DataView","size","type","readFile","call","e","target","error","console","log","buffer","result","dataView","offset","maxOffset","byteLength","headLength","markerBytes","markerLength","parsers","i","getUint16","disableMetaDataParsers","length","disableImageHead","imageHead","Uint8Array","subarray","replaceHead","blob","head","originalTransform","transform","img","hasMetaOption"],"sources":["/Users/mac/Downloads/ai-math-helper-complete/node_modules/blueimp-load-image/js/load-image-meta.js"],"sourcesContent":["/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim Stöhr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView, Uint8Array */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var hasblobSlice =\n    typeof Blob !== 'undefined' &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  loadImage.blobSlice =\n    hasblobSlice &&\n    function () {\n      var slice = this.slice || this.webkitSlice || this.mozSlice\n      return slice.apply(this, arguments)\n    }\n\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  // Parses image meta data and calls the callback with an object argument\n  // with the following properties:\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n  // The options argument accepts an object and supports the following\n  // properties:\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n  // * disableImageHead: Disables creating the imageHead property.\n  loadImage.parseMetaData = function (file, callback, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    // eslint-disable-next-line no-param-reassign\n    data = data || {}\n    var that = this\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\n    var maxMetaDataSize = options.maxMetaDataSize || 262144\n    var noMetaData = !(\n      typeof DataView !== 'undefined' &&\n      file &&\n      file.size >= 12 &&\n      file.type === 'image/jpeg' &&\n      loadImage.blobSlice\n    )\n    if (\n      noMetaData ||\n      !loadImage.readFile(\n        loadImage.blobSlice.call(file, 0, maxMetaDataSize),\n        function (e) {\n          if (e.target.error) {\n            // FileReader error\n            // eslint-disable-next-line no-console\n            console.log(e.target.error)\n            callback(data)\n            return\n          }\n          // Note on endianness:\n          // Since the marker and length bytes in JPEG files are always\n          // stored in big endian order, we can leave the endian parameter\n          // of the DataView methods undefined, defaulting to big endian.\n          var buffer = e.target.result\n          var dataView = new DataView(buffer)\n          var offset = 2\n          var maxOffset = dataView.byteLength - 4\n          var headLength = offset\n          var markerBytes\n          var markerLength\n          var parsers\n          var i\n          // Check for the JPEG marker (0xffd8):\n          if (dataView.getUint16(0) === 0xffd8) {\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific meta-data like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid meta data: Invalid segment size.')\n                  break\n                }\n                parsers = loadImage.metaDataParsers.jpeg[markerBytes]\n                if (parsers && !options.disableMetaDataParsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the meta data\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              if (buffer.slice) {\n                data.imageHead = buffer.slice(0, headLength)\n              } else {\n                // Workaround for IE10, which does not yet\n                // support ArrayBuffer.slice:\n                data.imageHead = new Uint8Array(buffer).subarray(0, headLength)\n              }\n            }\n          } else {\n            // eslint-disable-next-line no-console\n            console.log('Invalid JPEG file: Missing JPEG marker.')\n          }\n          callback(data)\n        },\n        'readAsArrayBuffer'\n      )\n    ) {\n      callback(data)\n    }\n  }\n\n  // Replaces the image head of a JPEG blob with the given one.\n  // Calls the callback with the new Blob:\n  loadImage.replaceHead = function (blob, head, callback) {\n    loadImage.parseMetaData(\n      blob,\n      function (data) {\n        callback(\n          new Blob(\n            [head, loadImage.blobSlice.call(blob, data.imageHead.byteLength)],\n            { type: 'image/jpeg' }\n          )\n        )\n      },\n      { maxMetaDataSize: 256, disableMetaDataParsers: true }\n    )\n  }\n\n  var originalTransform = loadImage.transform\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(\n        file,\n        function (data) {\n          originalTransform.call(loadImage, img, options, callback, file, data)\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}